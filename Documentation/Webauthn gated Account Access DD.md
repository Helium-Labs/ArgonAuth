# Research, Development & Due-Diligence around Account Access gated by Webauthn 

In layman terms, the proposal is to create an LSIG contract in the generic case which acts as an account with access gated by Webauthn (see *Section 1*). Then in *Section 2*, a high-level spec for a stateful escrow account is described that covers MBR and fees through a funder application.

## 1. LSIG Contract Account with Access Gated by Webauthn

A contract account that approves any TX from the account if a valid DIDT and Webauthn is provided.

### LSIG Contract Account Spec

```
immutable state:
 - PK_auth

assert(DIDT hasn't expired)
assert(DIDT signed with PK_auth)
assert(DIDT contains PK_sess)
assert(TX hash signed with PK_sess)
assert(lease)
assert(default checks)
```

Where:
- `DIDT`: decentralzied identity token, explained below.
- `PK_sess`: Ephermeral X25519 Ephemereal Session Access Token Public key, explained below.
- `PK_auth`: ES256 (secp256r1) credential public key for the credential, unique to the particular RP & chosen user handle.

### DIDT Spec

Specification for the DIDT (Decentralized Identifier Token):

1. **Structure**: The DIDT is a packed byte array composed of:

    - `PK_sess`: 32-byte public key derived from a base64 string.
    - `roundStart`: 8-byte block start round number derived from a base64 string.
    - `roundEnd`: 8-byte block end round number derived from a base64 string.
    - `randomString`: A string of arbitrary length (minimum 32 bytes), used as a challenge during the Webauthn ceremony.

2. **Creation**: Create the DIDT by concatenating `didtPubKey`, `roundStart`, `roundEnd`, and `randomString`:

    ```csharp
    byte[] PK_sess = Convert.FromBase64String(didtPubKeyAsBase64);
    byte[] roundStart = Convert.FromBase64String(roundStartAsUINT64BEBase64);
    byte[] roundEnd = Convert.FromBase64String(roundEndAsUINT64BEBase64);
    byte[] randomString = GetRandomBytes(minLength: 32); // Method to get a random string of bytes

    byte[] didt = PK_sess
                    .Concat(roundStart)
                    .Concat(roundEnd)
                    .Concat(randomString)
                    .ToArray();
    ```

3. **Usage**: The DIDT cerities validity of the `PK_sess`, and links it to the owner of the authenticator. The DIDT is signed with the authenticator, as it is taken as the challenge during the Webauthn ceremony.
This makes the DIDT perfect for gating access to contract accounts, and for authenticating a user for backend authorization where they sign payloads with the client-side (hidden) `SK_sess`.

4. **Definitions**:
    - `PK_sess`: 32-byte public key from the `sess` X25519 keypair created client-side, injected into the Webauthn (DIDT) challenge during the assertion ceremony. The DIDT is validated client-side to check the PK_sess sent in the AssertionOptions request is untampered in the response containing the challenge to sign, guarding against a MITM where someone elses DIDT is injected into the response for them to sign (denoted `DIDT client validation`).
    - `roundStart`: Creation date in terms of Algorand rounds.
    - `roundEnd`: Expiration date in terms of Algorand rounds.
    - `randomString`: Generated by the relying party, to guard against replay attacks during the Webauthn ceremony.


### Security Assessment

As strong as the Webauthn flow, where the only way to compromise the security is through a sophisticated phishing or MITM incident where a fake DIDT is issued and ultimately signed by the authenticator instead of the genuine one.

### Security Improvements

Supplying a server generated signature of a hash of the DIDT, so you can certify that the challenge successfully passed the Webauthn assertion according to the servers perspective. Otherwise during AssertionOptions, just before it's sent off for Assertion, a fake DIDT can be delivered. Crucially `DIDT client validation` prevents most MITM including injection of a fake DIDT into the AssertionOptions response, so this improvement isn't necessary.

Sources:
- https://www.w3.org/TR/webauthn-2
- https://www.w3.org/TR/webauthn-2/#public-key-credential-source
- https://www.w3.org/TR/webauthn-2/#credential-public-key

### Webauthn Ceremony Stages 

## Registration

The Registration Ceremony is no different to that found in FIDO2 as standardized by W3C.

![Webauthn Registration](https://www.w3.org/TR/webauthn-2/images/webauthn-registration-flow-01.svg)

## Authentication

The Authentication Ceremony is a superset of that found in FIDO2 as standardized by W3C, achieving full compliance for user account authentication. They differ in terms of challenge creation, where the client inserts a public key from a keypair created client-side for taking care of authentication for that session, along with Algorand round parameters that dictate its lifetime of access.

The server creates a DIDT from this, which includes a server generated random string following a standard FIDO2 Assertion ceremony. On receipt of the DIDT (which is the FIDO2 challenge), the client validates that the parameters match the values provided in the request, guarding against a MITM attack.

Upon server verification of the user signed challenge, the LSIG bytecode and sent back to the user along with their DIDT. The LSIG assertion logic takes care of authorizing transactions sent from the contract account, as described above.

![Webauthn Authentication](
https://raw.githubusercontent.com/mangoplane/KeychainRelyingParty/main/Documentation/Assertion.png?token=GHSAT0AAAAAACCYIYD2WKQ3UX4WWWQMWXDAZD6YGAQ)



### Assertion (Account Authentication)


## Key Management

- `sess` stored **in volatile memory** in the given Window thread for the lifetime the WebApp is open
- `sess` is further secured inside a **sandboxed iframe**, with heavily restricted permissions. Communication over the iframe happens across a barrier with JSON RPC method standardized message passing.
- A HTTP **CSP** (Content Security Policy) is in place to restrict the origin of scripts and images to a whitelist of origins, done to mitigate XSS (cross-site scripting).

Sources:
- https://web.dev/sandboxed-iframes/
- https://discord.com/channels/963742627918905374/1017642572065275954/1106879483828502558
- https://magic-whitepaper-key-based-authentication-system.s3.us-west-2.amazonaws.com/Magic+Whitepaper.pdf
- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP

## Signature Mode 

Logic signatures (lsigs) in Algorand refer to programs that execute in a constrained environment. These programs are stateless and are essentially digital signatures with embedded logic. They have no direct access to the majority of the blockchain state, except for the transaction they're validating and a small selection of global properties.

### Contract Account

If the SHA512_256 hash of the program (prefixed by "Program") is equal to authorizer address of the transaction sender then this is a contract account wholly controlled by the program. No other signature is necessary or possible. The only way to execute a transaction against the contract account is for the program to approve it.
*Meaning you can't use a multisignature to add another layer of security to a contract account*.

### Delegated Access

If the account has signed the program (by providing a valid ed25519 signature or valid multisignature for the authorizer address on the string "Program" concatenated with the program bytecode) then: if the program returns true the transaction is authorized as if the account had signed it. This allows an account to hand out a signed program so that other users can carry out delegated actions which are approved by the program. Note that Smart Signature Args are not signed.

### Important considerations

- The arguments are transparent to the world. Therefore never put sensitive access tokens or keys in the arguments.

Sources: 
- https://developer.algorand.org/docs/get-details/dapps/avm/teal/specification/#execution-environment-for-smart-signatures


## 2. Smart Contract specifically for a frictionless experience

Features:
- Covers Opt-In/MBR for assets & applications created by a list of pre-approved creators. MBR is reclaimable by the "global funder" application. Only this funder application can close out assets and opt-out of applications.
- Fees that are not covered via pooling are covered by the application. Done by including a "fee pooler" transaction in the group transaction to a "global funder" smart contract.
- Seamlessly handles all common TX such as pay, axfer, app call, ..., as if it were a regular account.
- Inner Transactions: since AVM 6, TEAL allows Inner Transactions with no limitations except for: stack depth of 8 for contract-contract calls, called contracts must also be AVM 6, & there's a max inner group transaction size of 256.

### Smart Contract Spec
```
global state:
- owner: address that owns this application
- funder: address that funds this application

InnerTxn NoOp Functions:
- payment(amt, to)
- transfer(amt, asaID, to)
- appCall(appId, OnComplete, AppArgs)
- composer(composes the above)
 
Auxiliary NoOp Functions:
- OptIn(asaID)
```

The InnerTxn NoOp Functions are each grouped with a fee pooler group transaction, whose purpose is to cover the fees across all transactions (the invoker, other tx in the group, and so forth).
`composer` uses a custom ABI datastructure to represent a group of inner transactions that are in terms of the other InnerTxn `payment`, `transfer` and `appCall`. Making it as flexible as a regular account, except for Oracle data which appears to be difficult to include (unless it's just a signed payload).
The InnerTxn certify the sender of the NoOp application call is the `owner` that's recorded in the global state.

### Cost Analysis

- Fee pooling would cost at least 3 x MinTXFee. To cover itself, the lsig initiating owner call, and the inner txn itself. Ideally have all purchase type TX cover its fee, pushed back onto the user.
- MBR is reclaimable, except for the MBR to create the escrow smart contract. An initial MBR of 0.1A to create the escrow smart contract is needed. If the LSIG creates the escrow SC, it doesn't need an additional 0.1A to Opt-In.

Sources:
- https://developer.algorand.org/docs/get-details/transactions/?from_query=fee%20pool#pooled-transaction-fees
- https://developer.algorand.org/docs/get-details/dapps/smart-contracts/apps/innertx
- https://github.com/FrankSzendzielarz/AlgorandVisualStudio/blob/main/Transactions/InnerTransactions.md



## 3. Rekeying a smart-signature to a multi-sig account for MFA delegated lsig access 

Relevant when wanting to add another factor of authenticator to signing requests. Ideally want a way to only require signing by the second factor for certain kinds of TX.
Rekeying a Smart-Signature, and accounts more generally, to include a second factor of authentication (another key):

### With Javascript

```javascript
const txn = //...
const signerAddrs: string[] = []
signerAccounts.push(acc.addr)
signerAccounts.push(smartSig.address())

// multiSigParams is used when creating the address and when signing transactions
const multiSigParams = {
  version: 1,
  threshold: 2,
  addrs: signerAddrs,
}
// First signature uses signMultisigTransaction
const msigWithFirstSig = algosdk.signMultisigTransaction(
  txn,
  multiSigParams,
  acc.sk
).blob
const signedDelegatedTxn = algosdk.signLogicSigTransactionObject(
  txn,
  smartSig
)
const msigWithAllSigs = algosdk.appendSignRawMultisigSignature(
  msigWithFirstSig,
  smartSig.address(),
  signedDelegatedTxn 
)
// submit...
```

Sources:
- https://algorand.github.io/js-algorand-sdk/functions/appendSignRawMultisigSignature.html
- https://developer.algorand.org/docs/get-details/transactions/signatures/#multisignatures
- https://developer.algorand.org/docs/get-details/dapps/smart-contracts/frontend/smartsigs/

### With CS

```csharp
// make the unsigned tx
PaymentTransaction transaction = new PaymentTransaction() 
{
    Fee=fee,
    FirstValid = fv,
    LastValid = lv,
    GenesisHash = new Digest(gh),
    Receiver = new Address(to),
    CloseRemainderTo = new Address(close),
    Amount = amt,
    GenesisID = gen,
    Note = Convert.FromBase64String(note)
};

// create an MSIG with which we'll sign it
var version = 1;
var threshold = 2;
MultisigSignature mSig = new MultisigSignature(version, threshold);

// add subsigs (at least threshold count worth)
// sign with the account
Account signingAccount = //... init
SignedTransaction accTxSig = transaction.sign(signingAccount);
mSig.Subsigs.Add(new MultisigSubsig(signingAccount.KeyPair.PublicKey, txSig.Sig));
// sign with the lsig
LogicsigSignature lsig = //... init
SignedTransaction lsigTxSig = transaction.sign(lsig);
mSig.Subsigs.Add(new MultisigSubsig(lsig.Address, lsigTxSig));

// sign original tx with the msig we just created. NOTE: there's no transaction.sign(msig) :(
SignedTransaction msigTxSig = new SignedTransaction(transaction, null, mSig, null, null);
// submit...
```

Sources:
- https://frankszendzielarz.github.io/dotnet-algorand-sdk/api/Algorand.MultisigSignature.html
- https://frankszendzielarz.github.io/dotnet-algorand-sdk/api/Algorand.MultisigSubsig.html
- https://frankszendzielarz.github.io/dotnet-algorand-sdk/api/Algorand.LogicsigSignature.html

