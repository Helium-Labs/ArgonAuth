# Research, Development & Due-Diligence around Account Access gated by Webauthn 

## LSIG Contract Account with Access Gated by Webauthn

A contract account that approves any TX from the account if a valid DIDT and Webauthn is provided.

### LSIG Spec

```
immutable state:
 - secp256r1 public key for the authenticator

assert(DIDT hasn't expired)
assert(DIDT signed with secp256r1 public key)
assert(DIDT contains PK_sess)
assert(TX hash signed with PK_sess)
assert(lease)
assert(default checks)
```

Where:
- `DIDT`: decentralzied identity token, explained below.
- `PK_sess`: Ephermeral X25519 Ephemereal Session Access Token Public key, explained below.

### DIDT Spec

Specification for the DIDT (Decentralized Identifier Token):

1. **Structure**: The DIDT is a packed byte array composed of:

    - `PK_sess`: 32-byte public key derived from a base64 string.
    - `roundStart`: 8-byte block start round number derived from a base64 string.
    - `roundEnd`: 8-byte block end round number derived from a base64 string.
    - `randomString`: A string of arbitrary length (minimum 32 bytes), used as a challenge during the Webauthn ceremony.

2. **Creation**: Create the DIDT by concatenating `didtPubKey`, `roundStart`, `roundEnd`, and `randomString`:

    ```csharp
    byte[] PK_sess = Convert.FromBase64String(didtPubKeyAsBase64);
    byte[] roundStart = Convert.FromBase64String(roundStartAsUINT64BEBase64);
    byte[] roundEnd = Convert.FromBase64String(roundEndAsUINT64BEBase64);
    byte[] randomString = GetRandomBytes(minLength: 32); // Method to get a random string of bytes

    byte[] didt = PK_sess
                    .Concat(roundStart)
                    .Concat(roundEnd)
                    .Concat(randomString)
                    .ToArray();
    ```

3. **Usage**: The DIDT cerities validity of the `PK_sess`, and links it to the owner of the authenticator. The DIDT is signed with the authenticator, as it is taken as the challenge during the Webauthn ceremony.
This makes the DIDT perfect for gating access to contract accounts, and for authenticating a user for backend authorization where they sign payloads with the client-side (hidden) `SK_sess`.

4. **Definitions**:
    - `PK_sess`: 32-byte public key from the `sess` X25519 keypair created client-side, injected into the Webauthn (DIDT) challenge during the assertion ceremony. The DIDT is validated client-side to check the PK_sess sent in the AssertionOptions request is untampered in the response containing the challenge to sign, guarding against a MITM where someone elses DIDT is injected into the response for them to sign (denoted `DIDT client validation`).
    - `roundStart`: Creation date in terms of Algorand rounds.
    - `roundEnd`: Expiration date in terms of Algorand rounds.
    - `randomString`: Generated by the relying party, to guard against replay attacks during the Webauthn ceremony.


### Security Assessment

As strong as the Webauthn flow, where the only way to compromise the security is through a sophisticated phishing or MITM incident where a fake DIDT is issued and ultimately signed by the authenticator instead of the genuine one.

### Security Improvements

Supplying a server generated signature of a hash of the DIDT, so you can certify that the challenge successfully passed the Webauthn assertion according to the servers perspective. Otherwise during AssertionOptions, just before it's sent off for Assertion, a fake DIDT can be delivered. Crucially `DIDT client validation` prevents most MITM including injection of a fake DIDT into their, so this improvement isn't necessary.

## Signature Mode 

Logic signatures (lsigs) in Algorand refer to programs that execute in a constrained environment. These programs are stateless and are essentially digital signatures with embedded logic. They have no direct access to the majority of the blockchain state, except for the transaction they're validating and a small selection of global properties.

### Contract Account

If the SHA512_256 hash of the program (prefixed by "Program") is equal to authorizer address of the transaction sender then this is a contract account wholly controlled by the program. No other signature is necessary or possible. The only way to execute a transaction against the contract account is for the program to approve it.
*Meaning you can't use a multisignature to add another layer of security to a contract account*.

### Delegated Access

If the account has signed the program (by providing a valid ed25519 signature or valid multisignature for the authorizer address on the string "Program" concatenated with the program bytecode) then: if the program returns true the transaction is authorized as if the account had signed it. This allows an account to hand out a signed program so that other users can carry out delegated actions which are approved by the program. Note that Smart Signature Args are not signed.

### Important considerations

- The arguments are transparent to the world. Therefore never put sensitive access tokens or keys in the arguments.

Sources: 
- https://developer.algorand.org/docs/get-details/dapps/avm/teal/specification/#execution-environment-for-smart-signatures


## Rekeying a smart-signature to a multi-sig account for MFA delegated lsig access 

Relevant when wanting to add another factor of authenticator to signing requests. Ideally want a way to only require signing by the second factor for certain kinds of TX.
Rekeying a Smart-Signature, and accounts more generally, to include a second factor of authentication (another key):

### With Javascript

```javascript
const txn = //...
const signerAddrs: string[] = []
signerAccounts.push(acc.addr)
signerAccounts.push(smartSig.address())

// multiSigParams is used when creating the address and when signing transactions
const multiSigParams = {
  version: 1,
  threshold: 2,
  addrs: signerAddrs,
}
// First signature uses signMultisigTransaction
const msigWithFirstSig = algosdk.signMultisigTransaction(
  txn,
  multiSigParams,
  acc.sk
).blob
const signedDelegatedTxn = algosdk.signLogicSigTransactionObject(
  txn,
  smartSig
)
const msigWithAllSigs = algosdk.appendSignRawMultisigSignature(
  msigWithFirstSig,
  smartSig.address(),
  signedDelegatedTxn 
)
// submit...
```

Sources:
- https://algorand.github.io/js-algorand-sdk/functions/appendSignRawMultisigSignature.html
- https://developer.algorand.org/docs/get-details/transactions/signatures/#multisignatures
- https://developer.algorand.org/docs/get-details/dapps/smart-contracts/frontend/smartsigs/

### With CS

```csharp
// make the unsigned tx
PaymentTransaction transaction = new PaymentTransaction() 
{
    Fee=fee,
    FirstValid = fv,
    LastValid = lv,
    GenesisHash = new Digest(gh),
    Receiver = new Address(to),
    CloseRemainderTo = new Address(close),
    Amount = amt,
    GenesisID = gen,
    Note = Convert.FromBase64String(note)
};

// create an MSIG with which we'll sign it
var version = 1;
var threshold = 2;
MultisigSignature mSig = new MultisigSignature(version, threshold);

// add subsigs (at least threshold count worth)
// sign with the account
Account signingAccount = //... init
SignedTransaction accTxSig = transaction.sign(signingAccount);
mSig.Subsigs.Add(new MultisigSubsig(signingAccount.KeyPair.PublicKey, txSig.Sig));
// sign with the lsig
LogicsigSignature lsig = //... init
SignedTransaction lsigTxSig = transaction.sign(lsig);
mSig.Subsigs.Add(new MultisigSubsig(lsig.Address, lsigTxSig));

// sign original tx with the msig we just created. NOTE: there's no transaction.sign(msig) :(
SignedTransaction msigTxSig = new SignedTransaction(transaction, null, mSig, null, null);
// submit...
```

Sources:
- https://frankszendzielarz.github.io/dotnet-algorand-sdk/api/Algorand.MultisigSignature.html
- https://frankszendzielarz.github.io/dotnet-algorand-sdk/api/Algorand.MultisigSubsig.html
- https://frankszendzielarz.github.io/dotnet-algorand-sdk/api/Algorand.LogicsigSignature.html
